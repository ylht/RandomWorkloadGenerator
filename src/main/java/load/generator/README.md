# 负载生成器

目录

[TOC]



# 引言

在数据库的研究中，经常会用各种benchmark来做性能的评测，比如常见的tpcc，smallbank等等，但是他们主要是为单一应用场景设计的负载模式，无法满足多样化的性能评测和数据库研究的需求。因此我们需要一款随机的负载生成器来模拟更加复杂的负载模式。它生成的负载理论上应该能覆盖当前所有常见的benchmark负载，并且可以生成更多的具有实际应用意义的负载。

为了得到真实有效的数据，我们统计了常用benchmark的数据，包括

+ 表格的基本信息，例如表格的大小，外键的参考情况，各种tuple的属性配置
+ 事务的信息，例如事务的数量，每种sql语句的特点，例如select的condition，属性分布，语句数量等等。

在模拟时，根据这些统计的信息，在合理的范围内动态的进行调整。我们将这些统计信息编写为xml配置文件，通过导入这些基本特征，确定生成的随机负载所依赖的表格特征和数据分布，之后确定随机产生的事务特征满足的特点和分布。

首先对于表格特征的随机，主要是每个tuple的具体信息，例如char的长度，decimal的长度和小数的位数，然后需要确定每种tuple的数量，和主键的数量，表格的数量，这些都需要用统计的数据进行约束。表格特征的难点在于外键的处理，如何的安排各个表格间的外键引用，如何保证外键引用之后的数据正确性，这两个点是需要重点关注的，首先对于第一个点，具体规则上采用了不引用已引用表的父表的原则，即如果还需要继续引入外键，那么它不应该是已引用表的引用表，在数据正确性上，首先保证所有的引用表在tuple标记上的范围上是全部存在的，并且在本表的tuple的tuple的各个特征也完全和原来的表相同。

对于事务的随机上，采用了事务模板和事务数据分离的做法，首先根据事务的基本特征和已经随机出的表格，确定事务的模板，然后将模板所需要的数据的特征，例如数据的范围和格式等等，导入给现有的数据生成器链表，每次事务执行时，一次调用所有的数据生成器产生事务模板所需要的数据。

在本篇文章接下来的篇幅，会依次讲述，数据统计的具体内容和数据的部分分析结果，在级出数据结构上的设计和整个系统模块的设计，以及系统的运行和配置方法。

# 数据统计

本项目主要统计了常见的四个benchmark的负载数据，分别为TPCC，Tatp，SmallBank和Seats。其中前3个benchmark 的统计来自官方文档的表述，Seats的统计来自于oltp的实现。统计数据的具体结果放在本项目的根目录下，可自行查阅。统计数据包括table数据和事务的sql数据。下面将选取一些数据做具体表述：

## table数据

初始统计数据分别为：表的主键数量，外键的数量，各个的属性的数量，其中统计的属性包括int，decimal，timestamp，char，varchar，float 。数据统计之后分析了table的tuple总数量概率分布，和具体的属性数量的概率分布。分析结果如下：

![image-20180904213539372](https://ws1.sinaimg.cn/large/006tNbRwly1fuxu5ciwuxj30p80smdjl.jpg)

除了属性的数量信息，还统计了属性的一些内容信息，比如varchar和char的区间长度，decimal整数位和小数位的区别，最后统计了下对于所有的table来说每个属性的范围值

![image-20180904213700763](https://ws3.sinaimg.cn/large/006tNbRwly1fuxu51rc58j30pm0v8jvm.jpg)

**关于键和结构的分析**

从统计结果来看，对于任意一个存在真实意义的表都满足以下的键值组成。

1. 主键有多列属性

   一般只有一列是单独列，即不参考其他表的列，如下图中的KeyRate，其他用于组成主键的列，如FK1和FK2都是外键。

2. 主键只有一列属性

   如果主键只有一列，那么一般不会参考外键。

3. 外键数量

   一般来说主键的部分列会使用外键参考其他的表，并且除主键外，其他的属性列也会有可能产生外键引用，表的数量一般由KeyRate* （FK1 *... * FKn）计算来给出。

![image-20180910210502115](https://ws2.sinaimg.cn/large/006tNbRwly1fv4qxmvr1wj31500ikta4.jpg)

## sql数据

1. 按照事务分别统计了事务的组成分布，主要包括select，update，delete和insert在每个事务中的数量。分析统计了每种语句在事务中的概率分布。
2. 对于select语句统计了各个属性的selcet数量，condition的类别，orderby的选择，limit的应用和是否存在sum，count等操作
3. 对于update语句统计了各个属性的update数量，和rw和w的比例（rw：a=a+b型语句；w：a=b型语句）
4. 对于insert语句统计了插入非主键属性的数量
5. 对于delete语句统计了condition 的条件

# 系统架构

系统的架构图如下：

![负载生成器架构图](https://ws4.sinaimg.cn/large/006tNbRwly1fv4qs7790kj30pi0c4dhd.jpg)

包含3个模块，分别是数据模块，功能模块和连接模块，箭头描述的是数据传递的路径，接下来将分3个章节来具体表述这3个模块。

## 数据模块

基础的数据结构模块，包含表格的结构，随机数据生成器和键值数据生成器。

### 表格结构

表格table由tuple子结构，外键引用和表格基础属性组成。

1. tuple子结构

   Table的基础结构是tuple，tuple按照基本的类型来区别，tuple的类型包括int, decimal, float, char, varchar, date。每个tuple维护自己的数据区间和数据格式。

   + 数据区间为数据的合法区间。例如，在int/decimal等数值型tuple中，数据区间为数据的最小值和最大值；在char类型中，数据区间代表数据的长度或者数据的基础库，比如姓氏库或者省份名称库等等
   + 数据格式为数据的格式要求，例如在decimal中的总位数和小数点后的位数。

2. 表格的基础属性

   包括表格的主键数量，表大小等基础数据

3. 外键引用

   由TupleForeign维护，记录本表引用的表，引用的列，本表中引用这些列的列。

### 随机数据生成器的结构

数据生成器从对应的tuple中获取数据区间，在数据区间中按照一定的规则生成随机数据。数据生成的类型有四种，分别为int，demical，date和char。

+ int维持两种数据生成器，一种是随机生成器用于生成随机的int数据，一种是自增列，用于生成主键的自增序列
+ demical维持在数值范围区间内的随机生成器
+ char维持3中随机生成器
  + 从对应的主键列的数据int转化为char，超过长度则截断，不足长度在头部补0
  + 在数据长度的范围内随机所有字母
  + 首先生成字符库，之后在字符库中随机
+ date维持时间的生成器，返回当前的时间。

### 键值数据生成器的结构

键值生成器主要用于生成合法的主键，主要是给出两种主键。

1. 无序键值，比如select或者update的主键，给出在主键数据的合法区间内的一个随机键值
   1. 如果键值存在1列的话，那么在这一列的数据区间内随机即可
   2. 如果键值存在多列，在多列的合法范围内依次随机即可
2. 有序键值，比如insert或者delete的主键，按照固定的顺序给出一个键值。在delete的时候键值是从头部依次向下给出，即delete数据从上向下删除，insert的数据从尾部向下给出
   1. 如果键值存在1列，那么delete从最小的值开始给出，同时将本列允许的最小值变为delete的值+1;insert从最的值开始给出，如果没有值insert便从当前的允许的最小值开始给出
   2. 如果键值存在多列，delete和insert的规则依然不变。在这种情况下键值的比较可以看作一个多位数，优先比较高位（高位为在左边的列），如果高位相同则继续向下比较，直到比较出大小。这样就可以得到最小值和最大值。而键值的递增是从低位到高位的，每次最低位加1，如果超过范围允许的最大值，则将改列重置为范围允许的最小值，并向高位进1，依次进行。

## 功能模块

功能模块主要包括4个，表格的scheme生成，表格的数据生成，负载生成，多线程执行下面简述主要功能逻辑：

### scheme生成

1. 按照统计的数据随机生成table 的数量

2. 按照统计的数据随机生成每种类型的tuple的数量，并按照统计数据随机实例化不同的tuple

3. 生成主键属性数量（如果是第N张表，主键必定小于等于N个属性，否则没有参考值），主键的第一列为KeyRate，代表本表的表的缩放比例，如果只有一个属性，那么KeyRate的范围就是表的数量大小。

4. 按照统计的数据随机生成外键的数量，之后确定外键的引用关系，在统计时我们发现了一些参考关系，一般如果表A参考了表B，那么表A基本不会参考表B所参考的表，所以我们定义了一个名词，称之为参考层级。具体定义为

   > 1. 当表没有参考其他的表时，其参考层级定义为1
   > 2. 当表有参考其他的表时，其参考层级定义为所有被参考的表中层级最大的值加1

   如下图：

   ![image-20180912145417483](/Users/wangqingshuai/Library/Application Support/typora-user-images/image-20180912145417483.png)

   表1的参考层级为1，由于表2参考表1，所以为2，同时表3无参考层级为1，而表4显然，取最大值为2，然后加1为3。同时为了表述具体的引用关系，我们定义一个有向无环图，用引用层级来表述表的位置。根据我们之前提到的KeyRate，由于FKn的范围都是从外键引用而来，所以从根本上看表的数量是由KeyRate来控制的，所以我们根据不同的层级定义不同的比例关系，例如我们可以定义如果层级为1，那么KeyRate可以在10到100之间，随着层级的扩大KeyRate的范围也可以放大，这样层级越大的表的数量也会越多，类比到现实中也大多是这样的。事务如果存在增删操作的话也会放在层级最大的表上进行操作，因为他们的表的数据量比较大，也比较符合现实的应用场景。在这个随机生成数据的时候，KeyRate在每一层的放缩比例也是由统计给出的。

   在外键引用的时候，我们会选择任意一张之前出现过的表，选择其所有的主键属性作为外键，同时将这张表和被引用的表，递归的标记为不可引用，如果外键的引用数量不足，继续选择其他可以选择的表作为外键引用。

### 数据生成

1. 按照表的顺序生成随机数据，防止出现外键依赖
2. 对于每一张表，按照相应的tuple获取其数据区间，生成对应的随机数据生成器
3. 对于每一张表，按照主键的数据区间，生成对应的键值数据生成器
4. 根据table中设定的表大小，循环生成每一行数据，将其写入文件
5. 循环执行1到4直到将所有的table数据生成完毕
6. 将数据导出到文件中，之后将数据传输到数据库

### 负载生成

负载生成主要包括负载模板生成，随机生成器组合，顺序打乱。

1. 负载模版生成

首先分析一下简单的sql语句的组成，将下面的各种属性分解，（value）+使用正则表达式的方式表达。那么共同点基本上就是Att，TableName和ConditionSentence。

+ Att和TableName，基本上都是随机选择的
+ Condition，其中除了select中的conditionSentence之外，其他的都是全部的主键属性用于确定，而select中还会有其他的各种不同的condition，在基础版的实现中，只关注了基本的condition条件，即完全的主键选择

> + **SELECT** **(Att)+** **FROM**  **(TableName)**  **(ConditionSentence)**
>
> - **UPDATE**  **(TableName)**  **(SET Att=?)+**  **(ConditionSentence)**
>
> - **INSERT** **(TableName)** **VALUES** **(KeyValues)+** **(Att)\*** **(?)+**
>
> - **DELETE FROM**  **(TableName)** **(ConditionSentence)**
> -  **ConditionSentence**  ： **where  (Att=?)+**

下面将分语句描述我们需要做的模板填充操作

**Select模板**

随机生成select中的int属性，char属性等各个属性的数目，从表中筛选出相应数目的属性名称；

条件选择：

+ 主键选择，选择这张表的全部主键属性作为条件
+ 缺失一个主键，可能存在order by和limit
+ 缺失一个主键，在一个其他属性上取值或者range，例如选择姓氏
+ 缺失两个主键（在其他的一个属性上取range或者定值）
+ 两表join，包含上述的约束条件

**Update模板**

随机生成update中的int属性，char属性等各个属性的数目，从表中筛选出相应数目的属性名称；

按照随机比例分配，rw和w的数目，rw例为a=a+1，w例为a=1；

条件选择：主键选择，选择这张表的全部主键属性作为条件

**Delete模板**

条件选择：主键选择，选择这张表的全部主键属性作为条件

**Insert模板**

随机生成update中的int属性，char属性等各个属性的数目，从表中筛选出相应数目的属性名称；

条件选择：主键选择，选择这张表的全部主键属性作为条件

2. 数据生成器

   + 按照负载模板中对应的列，从对应的tuple中获取range，生成随机生成器序列
   + 按照负载模板中对应的condition，选择对应表的键值生成器，用于做键值数据生成

3. 顺序打乱

   顺序打乱主要有两种方法。

   - 生成所有的事务一共所需的各种语句的模板，无放回的每次抽一个语句，组成各个事务
   - 为每个事务随机生成数量确定的各种语句，之后打乱顺序

### 多线程执行

将事务集的实例分配给多个线程，每个线程维持一个数据库连接，将事务的sql语句预编译为stmt。每次随机一个事务，事务内部调用键值数据生成器获取condition的条件数据，调用随机数据生成器获取属性数据，补全事务模板，输出sql语句交给线程连接提交，完成随机负载。

## 连接模块

用于维持和数据库的连接，通过适配不同的驱动可以连接多种数据库

# 使用方法

## 配置

1. 系统要求

   项目使用jdk10开发，采用maven作为包管理器，无需引入其他包。

2. 配置文件

   配置文件包含两个，分别为benchmarkConfig.xml和database.xml,其中benchmarkConfig中主要是要配置数据生成的统计信息，database主要用书配置数据库的连接信息。

   benchmark的配置如下：

   分为表格和事务，表格的配置包括基本的属性配置和每个tuple配置，事务的配置包括事务的基本配置和每种sql的配置

   ![image-20180912192148076](https://ws4.sinaimg.cn/large/006tNbRwly1fv6z6tu6cpj30fa0wcdi8.jpg)

   ## 运行

   使用idea导入项目工程，运行`/Adaptive_Concurrency_Control/src/main/java/load/generator/main`文件夹下的AccMain.java即可。

